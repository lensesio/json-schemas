{
  "$schema" : "http://json-schema.org/draft-07/schema#",
  "$id" : "https://github.com/lensesio/stream-reactor/GCPStorageSourceConnector/10.0.0",
  "type" : "object",
  "title" : "GCPStorage Source Configuration",
  "description" : "Configuration schema for GCPStorageSourceConnector connector",
  "version" : "10.0.0",
  "properties" : {
    "connector.class" : {
      "default" : "io.lenses.streamreactor.connect.gcp.storage.source.GCPStorageSourceConnector",
      "description" : "Class name of the connector",
      "type" : "string",
      "title" : "connector.class"
    },
    "name" : {
      "description" : "Name of the connector",
      "type" : "string",
      "title" : "name"
    },
    "tasks.max" : {
      "default" : "1",
      "description" : "Maximum number of tasks to create",
      "type" : "integer",
      "minimum" : 1
    },
    "topics" : {
      "description" : "Comma-separated list of topics to produce to",
      "type" : "string",
      "title" : "topics"
    },
    "connect.gcpstorage.error.policy" : {
      "default" : "THROW",
      "description" : "\nSpecifies the action to be taken if an error occurs while inserting the data.\n There are three available options:\n    NOOP - the error is swallowed\n    THROW - the error is allowed to propagate.\n    RETRY - The exception causes the Connect framework to retry the message. The number of retries is set by connect.gcp.max.retries.\nAll errors will be logged automatically, even if the code swallows them.\n    ",
      "type" : "string",
      "title" : "connect.gcpstorage.error.policy"
    },
    "connect.gcpstorage.max.retries" : {
      "default" : 20,
      "description" : "The maximum number of times to try the write again.",
      "type" : "integer",
      "title" : "connect.gcpstorage.max.retries"
    },
    "connect.gcpstorage.retry.interval" : {
      "default" : 60000,
      "description" : "The time in milliseconds between retries.",
      "type" : "integer",
      "title" : "connect.gcpstorage.retry.interval"
    },
    "connect.gcpstorage.compression.codec" : {
      "default" : "UNCOMPRESSED",
      "description" : "Compression codec to use for Avro, Parquet or JSON.",
      "type" : "string",
      "title" : "connect.gcpstorage.compression.codec"
    },
    "connect.gcpstorage.compression.level" : {
      "default" : -1,
      "description" : "Certain compression codecs require a level specified.",
      "type" : "integer",
      "title" : "connect.gcpstorage.compression.level"
    },
    "connect.gcpstorage.gcp.project.id" : {
      "default" : "",
      "description" : "GCP Project ID",
      "type" : "string",
      "title" : "connect.gcpstorage.gcp.project.id"
    },
    "connect.gcpstorage.gcp.quota.project.id" : {
      "default" : "",
      "description" : "GCP Quota Project ID",
      "type" : "string",
      "title" : "connect.gcpstorage.gcp.quota.project.id"
    },
    "connect.gcpstorage.endpoint" : {
      "default" : "",
      "description" : "GCP Host",
      "type" : "string",
      "title" : "connect.gcpstorage.endpoint"
    },
    "connect.gcpstorage.http.max.retries" : {
      "default" : 36,
      "description" : "Number of times to retry the http request, in the case of a resolvable error on the server side.",
      "type" : "integer",
      "title" : "connect.gcpstorage.http.max.retries"
    },
    "connect.gcpstorage.http.retry.interval" : {
      "default" : 500,
      "description" : "If greater than zero, used to determine the delay after which to retry the http request in milliseconds.  Based on an exponential backoff algorithm.",
      "type" : "integer",
      "title" : "connect.gcpstorage.http.retry.interval"
    },
    "connect.gcpstorage.http.retry.timeout.multiplier" : {
      "default" : 3.0,
      "description" : "This controls the change in delay before the next retry or poll",
      "type" : "number",
      "title" : "connect.gcpstorage.http.retry.timeout.multiplier"
    },
    "connect.gcpstorage.gcp.auth.mode" : {
      "default" : "DEFAULT",
      "description" : "Authenticate mode, 'credentials', 'file', 'default' or 'none'",
      "type" : "string",
      "title" : "connect.gcpstorage.gcp.auth.mode"
    },
    "connect.gcpstorage.gcp.credentials" : {
      "default" : "[hidden]",
      "description" : "GCP Credentials if using 'credentials' auth mode.",
      "type" : "string",
      "title" : "connect.gcpstorage.gcp.credentials"
    },
    "connect.gcpstorage.gcp.file" : {
      "default" : "",
      "description" : "File containing GCP Credentials if using 'file' auth mode.  This can be relative from the current working directory of the java process or from the root.  Remember your path format is operating system dependent. (eg for unix-based /home/my/path/file)",
      "type" : "string",
      "title" : "connect.gcpstorage.gcp.file"
    },
    "connect.gcpstorage.kcql" : {
      "description" : "Contains the Kafka Connect Query Language describing data mappings from the source to the target system.",
      "type" : "string",
      "title" : "connect.gcpstorage.kcql"
    },
    "connect.gcpstorage.ordering.type" : {
      "default" : "AlphaNumeric",
      "description" : "AlphaNumeric (the default)",
      "type" : "string",
      "title" : "connect.gcpstorage.ordering.type"
    },
    "connect.gcpstorage.source.partition.search.recurse.levels" : {
      "default" : 0,
      "description" : "When searching for new partitions on the S3 filesystem, how many levels deep to recurse.",
      "type" : "integer",
      "title" : "connect.gcpstorage.source.partition.search.recurse.levels"
    },
    "connect.gcpstorage.source.partition.search.continuous" : {
      "default" : true,
      "description" : "If set to true, it will be continuously search for new partitions. Otherwise it is a one-off operation. Defaults to true.",
      "type" : "boolean",
      "title" : "connect.gcpstorage.source.partition.search.continuous"
    },
    "connect.gcpstorage.source.partition.search.interval" : {
      "default" : 300000,
      "description" : "The interval in milliseconds between searching for new partitions.  Defaults to 5 minutes.",
      "type" : "integer",
      "title" : "connect.gcpstorage.source.partition.search.interval"
    },
    "connect.gcpstorage.source.partition.search.excludes" : {
      "default" : ".indexes",
      "description" : "Comma-separated list of directory prefixes to exclude from the partition search",
      "type" : "string",
      "title" : "connect.gcpstorage.source.partition.search.excludes"
    },
    "connect.gcpstorage.source.partition.extractor.type" : {
      "description" : "If you want to read to specific partitions when running the source.  Options are 'hierarchical' (to match the sink's hierarchical file storage pattern) and 'regex' (supply a custom regex).  Any other value will ignore original partitions and they should be evenly distributed through available partitions (Kafka dependent).",
      "type" : "string",
      "title" : "connect.gcpstorage.source.partition.extractor.type"
    },
    "connect.gcpstorage.source.partition.extractor.regex" : {
      "description" : "If reading filename from regex, supply the regex here.",
      "type" : "string",
      "title" : "connect.gcpstorage.source.partition.extractor.regex"
    },
    "connect.gcpstorage.source.extension.excludes" : {
      "description" : "Comma-separated list of file extensions to exclude from the source file search. If not configured, no files will be excluded. When used in conjunction with 'source.extension.includes', files must match the includes list and not match the excludes list to be considered.",
      "type" : "string",
      "title" : "connect.gcpstorage.source.extension.excludes"
    },
    "connect.gcpstorage.source.extension.includes" : {
      "description" : "Comma-separated list of file extensions to include in the source file search. If not configured, all files are considered. When used in conjunction with 'source.extension.excludes', files must match the includes list and not match the excludes list to be considered.",
      "type" : "string",
      "title" : "connect.gcpstorage.source.extension.includes"
    },
    "connect.gcpstorage.source.empty.results.backoff.initial.delay" : {
      "default" : 1000,
      "description" : "Initial delay in milliseconds before retrying when no results are found.",
      "type" : "integer",
      "title" : "connect.gcpstorage.source.empty.results.backoff.initial.delay"
    },
    "connect.gcpstorage.source.empty.results.backoff.max.delay" : {
      "default" : 10000,
      "description" : "Maximum delay in milliseconds before retrying when no results are found.",
      "type" : "integer",
      "title" : "connect.gcpstorage.source.empty.results.backoff.max.delay"
    },
    "connect.gcpstorage.source.empty.results.backoff.multiplier" : {
      "default" : 2.0,
      "description" : "Multiplier to apply to the delay when retrying when no results are found.",
      "type" : "number",
      "title" : "connect.gcpstorage.source.empty.results.backoff.multiplier"
    },
    "connect.gcpstorage.source.write.watermark.headers" : {
      "default" : false,
      "description" : "When outputting source records, include the watermark in the headers of the source record",
      "type" : "boolean",
      "title" : "connect.gcpstorage.source.write.watermark.headers"
    },
    "transforms" : {
      "description" : "Comma-separated list of transformations to apply",
      "type" : "string"
    },
    "transforms.{name}.type" : {
      "description" : "Type of the transformation",
      "type" : "string"
    },
    "transforms.{name}.predicate" : {
      "description" : "Predicate for the transformation",
      "type" : "string"
    },
    "transforms.{name}.negate" : {
      "default" : false,
      "description" : "Whether to negate the predicate",
      "type" : "boolean"
    },
    "predicates" : {
      "description" : "Comma-separated list of predicates",
      "type" : "string"
    },
    "predicates.{name}.type" : {
      "description" : "Type of the predicate",
      "type" : "string"
    },
    "predicates.{name}.field" : {
      "description" : "Field to evaluate (for field-based predicates)",
      "type" : "string"
    },
    "config.providers" : {
      "description" : "Comma-separated list of config provider aliases",
      "type" : "string"
    },
    "config.providers.{name}.type" : {
      "description" : "Type of the config provider",
      "type" : "string"
    }
  },
  "required" : [ "connector.class", "name", "tasks.max", "topics", "connect.gcpstorage.error.policy", "connect.gcpstorage.gcp.project.id", "connect.gcpstorage.gcp.quota.project.id", "connect.gcpstorage.gcp.auth.mode", "connect.gcpstorage.gcp.credentials", "connect.gcpstorage.gcp.file", "connect.gcpstorage.kcql" ]
}